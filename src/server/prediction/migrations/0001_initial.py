# Generated by Django 3.2.23 on 2024-02-16 19:29

import django.contrib.gis.db.models.fields
from django.db import migrations, models
import django.db.models.deletion
import django.utils.timezone


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('report', '0005_remove_report_ttl'),
    ]

    operations = [
        migrations.CreateModel(
            name='TrainingData',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created', models.DateTimeField(auto_now_add=True)),
                ('modified', models.DateTimeField(auto_now=True)),
                ('training_days', models.PositiveIntegerField(help_text='Total number of days to use in the training set,             i.e. 90 for reports from last 90 days.')),
                ('eps', models.FloatField(default=0.65, help_text='The maximum distance between two samples (in kms) for one to be              considered as in the neighborhood of the other. This is not a                  maximum bound on the distances of points within a cluster.')),
                ('min_samples', models.IntegerField(default=1, help_text='The number of samples in a neighborhood for a point to be              considered as a core point. This includes the point itself.')),
                ('min_cluster_reports', models.PositiveIntegerField(default=20, help_text='Min reports count for a cluster to be considered')),
                ('outliers_included', models.BooleanField(default=False, help_text='Turning this on will make clusters less dense and less            accurate but will show all reports.')),
                ('clusters_by_period', models.BooleanField(default=True, help_text='Turning this off will show all reports in a cluster            regardless of periods')),
                ('description', models.CharField(blank=True, help_text='A small description to track changes', max_length=250, null=True)),
            ],
            options={
                'verbose_name_plural': 'Training data',
            },
        ),
        migrations.CreateModel(
            name='WeeklyPeriod',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created', models.DateTimeField(auto_now_add=True)),
                ('modified', models.DateTimeField(auto_now=True)),
                ('start_date', models.DateTimeField(default=django.utils.timezone.now)),
                ('end_date', models.DateTimeField(default=django.utils.timezone.now)),
            ],
            options={
                'ordering': ['-id'],
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='DBSCANModel',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created', models.DateTimeField(auto_now_add=True)),
                ('modified', models.DateTimeField(auto_now=True)),
                ('eps', models.FloatField(default=0.5, help_text='The maximum distance between two samples for one to be              considered as in the neighborhood of the other. This is not a                  maximum bound on the distances of points within a cluster.')),
                ('min_samples', models.IntegerField(default=5, help_text='The number of samplesin a neighborhood for a point to be              considered as a core point. This includes the point itself.')),
                ('metric', models.CharField(default='euclidean', help_text='The metric to use when calculating distance between            instances in a feature array. If metric is a string or            callable, it must be one of the options allowed by             sklearn.metrics.pairwise_distances for its metric parameter.            If metric is “precomputed”, X is assumed to be             distance matrix and must be square. X may be a            sparse graph, in which case only “nonzero”            elements may be considered neighbors for DBSCAN.', max_length=50)),
                ('metric_params', models.JSONField(blank=True, default=None, help_text='Additional keyword arguments for the metric function.', null=True)),
                ('algorithm', models.CharField(choices=[('auto', 'auto'), ('ball_tree', 'ball_tree'), ('kd_tree', 'kd_tree'), ('brute', 'brute')], default='auto', help_text='The algorithm to be used by the NearestNeighbors module to compute            pointwise distances and find nearest neighbors.', max_length=10)),
                ('leaf_size', models.IntegerField(default=30, help_text='Leaf size passed to BallTree or cKDTree.')),
                ('p', models.FloatField(default=None, help_text='The power of the Minkowski metric to be used to calculate            distance between points. If None, then p=2            (equivalent to the Euclidean distance).', null=True)),
                ('n_jobs', models.IntegerField(default=None, help_text='The number of parallel jobs to run. None means 1 unless              in a joblib.parallel_backend context.                  -1 means using all processors..', null=True)),
                ('homogeneity_score', models.FloatField(default=None, help_text='A clustering result satisfies homogeneity if all of its              clusters contain only data points which are members of a single                  class. Score between 0.0 and 1.0. 1.0 stands for perfectly                      homogeneous labeling.', null=True)),
                ('completeness_score', models.FloatField(default=None, help_text='A clustering result satisfies completeness if all the data              points that are members of a given class are elements of the                same cluster. Score between 0.0 and 1.0. 1.0 stands for                      perfectly complete labeling.', null=True)),
                ('v_measure_score', models.FloatField(default=None, help_text='The V-measure is the harmonic mean between homogeneity              and completeness. Score between 0.0 and 1.0. 1.0 stands for                  perfectly complete labeling.', null=True)),
                ('adjusted_rand_score', models.FloatField(default=None, help_text='Similarity score between -0.5 and 1.0.              Random labelings have an ARI close to 0.0. 1.0 stands                  for perfect match.', null=True)),
                ('adjusted_mutual_info_score', models.FloatField(default=None, help_text='The AMI returns a value of 1 when the two partitions are              identical (ie perfectly matched).              Random partitions (independent labellings) have an expected AMI                  around 0 on average hence can be negative.', null=True)),
                ('silhouette_score', models.FloatField(default=None, help_text='The best value is 1 and the worst value is -1.             Values near 0 indicate overlapping clusters. Negative values                  generally indicate that a sample has been assigned to the                      wrong cluster, as a different cluster is more similar.', null=True)),
                ('period', models.ForeignKey(blank=True, help_text='Reports will be filtered by period before training.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='dbscan_models', to='prediction.weeklyperiod')),
                ('training_data', models.ForeignKey(blank=True, help_text='Reports will be filtered by period before training.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='dbscan_models', to='prediction.trainingdata')),
            ],
            options={
                'verbose_name_plural': 'DBSCAN Trained Models',
                'unique_together': {('training_data', 'period')},
            },
        ),
        migrations.CreateModel(
            name='ClusterGroup',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created', models.DateTimeField(auto_now_add=True)),
                ('modified', models.DateTimeField(auto_now=True)),
                ('centroid_location', django.contrib.gis.db.models.fields.PointField(srid=4326)),
                ('reports', models.ManyToManyField(blank=True, related_name='cluster_groups', to='report.Report')),
                ('trained_model', models.ForeignKey(blank=True, help_text='Reports will be filtered by period before training', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='cluster_groups', to='prediction.dbscanmodel')),
            ],
            options={
                'ordering': ['-id'],
                'abstract': False,
            },
        ),
    ]
